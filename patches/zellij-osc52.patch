From 05ccd561ace3ef6ea44339a5916a4b6dae913e20 Mon Sep 17 00:00:00 2001
From: Rohan Godha <git@rohangodha.com>
Date: Tue, 4 Nov 2025 12:47:03 -0500
Subject: [PATCH] Add OSC52 clipboard query passthrough

---
 zellij-client/src/input_handler.rs            |   6 +
 zellij-client/src/lib.rs                      |  27 ++
 zellij-client/src/stdin_ansi_parser.rs        |  80 +++++-
 zellij-client/src/stdin_handler.rs            |  16 +-
 .../src/web_client/server_listener.rs         |   6 +
 zellij-server/src/panes/grid.rs               |  15 +-
 zellij-server/src/panes/terminal_pane.rs      |   4 +
 zellij-server/src/route.rs                    |  13 +
 zellij-server/src/screen.rs                   |  30 +++
 zellij-server/src/tab/mod.rs                  | 194 ++++++++++++--
 .../prost_ipc/client_server_contract.rs       | 250 ++++++++++--------
 .../client_to_server.proto                    |   5 +
 .../server_to_client.proto                    |   5 +
 zellij-utils/src/errors.rs                    |   1 +
 zellij-utils/src/ipc.rs                       |   6 +
 zellij-utils/src/ipc/protobuf_conversion.rs   |  26 +-
 16 files changed, 531 insertions(+), 153 deletions(-)

diff --git a/zellij-client/src/input_handler.rs b/zellij-client/src/input_handler.rs
index d2cee2e0..08c0e3cf 100644
--- a/zellij-client/src/input_handler.rs
+++ b/zellij-client/src/input_handler.rs
@@ -306,6 +306,12 @@ impl InputHandler {
                     .send(ClientInstruction::SetSynchronizedOutput(enabled))
                     .unwrap();
             },
+            AnsiStdinInstruction::ClipboardContent(clipboard_bytes) => {
+                self.os_input
+                    .send_to_server(ClientToServerMsg::Osc52ClipboardContent {
+                        clipboard_content: clipboard_bytes,
+                    });
+            },
         }
     }
     fn handle_mouse_event(&mut self, mouse_event: &MouseEvent) {
diff --git a/zellij-client/src/lib.rs b/zellij-client/src/lib.rs
index 6c7bb11d..30680b10 100644
--- a/zellij-client/src/lib.rs
+++ b/zellij-client/src/lib.rs
@@ -114,6 +114,7 @@ pub(crate) enum ClientInstruction {
     #[allow(dead_code)] // we need the session name here even though we're not currently using it
     RenamedSession(String), // String -> new session name
     ConfigFileUpdated,
+    StartOsc52ClipboardQuery(Vec<u8>),
 }
 
 impl From<ServerToClientMsg> for ClientInstruction {
@@ -136,6 +137,9 @@ impl From<ServerToClientMsg> for ClientInstruction {
             ServerToClientMsg::StartWebServer => ClientInstruction::StartWebServer,
             ServerToClientMsg::RenamedSession { name } => ClientInstruction::RenamedSession(name),
             ServerToClientMsg::ConfigFileUpdated => ClientInstruction::ConfigFileUpdated,
+            ServerToClientMsg::StartOsc52ClipboardQuery { selector } => {
+                ClientInstruction::StartOsc52ClipboardQuery(selector)
+            },
         }
     }
 }
@@ -160,6 +164,9 @@ impl From<&ClientInstruction> for ClientContext {
             ClientInstruction::StartWebServer => ClientContext::StartWebServer,
             ClientInstruction::RenamedSession(..) => ClientContext::RenamedSession,
             ClientInstruction::ConfigFileUpdated => ClientContext::ConfigFileUpdated,
+            ClientInstruction::StartOsc52ClipboardQuery(..) => {
+                ClientContext::StartedParsingStdinQuery
+            },
         }
     }
 }
@@ -1043,6 +1050,26 @@ pub fn start_client(
                     },
                 }
             },
+            ClientInstruction::ConfigFileUpdated => {
+                if let Some(config_file) = cli_args.config.clone() {
+                    println!(
+                        "Config file {config_file:?} was updated successfully. Restart Zellij to apply changes."
+                    );
+                } else {
+                    println!(
+                        "Config file was updated successfully. Restart Zellij to apply changes."
+                    );
+                }
+            },
+            ClientInstruction::StartOsc52ClipboardQuery(selector) => {
+                log::debug!(
+                    "Server requested OSC 52 clipboard query with selector {:?}",
+                    String::from_utf8_lossy(&selector)
+                );
+                if let Ok(mut parser) = stdin_ansi_parser.lock() {
+                    parser.expect_clipboard_response();
+                }
+            },
             _ => {},
         }
     }
diff --git a/zellij-client/src/stdin_ansi_parser.rs b/zellij-client/src/stdin_ansi_parser.rs
index 7fa3492e..a90e3fe0 100644
--- a/zellij-client/src/stdin_ansi_parser.rs
+++ b/zellij-client/src/stdin_ansi_parser.rs
@@ -1,6 +1,7 @@
 use std::time::{Duration, Instant};
 
 const STARTUP_PARSE_DEADLINE_MS: u64 = 500;
+const CLIPBOARD_PARSE_DEADLINE_MS: u64 = 2000;
 use lazy_static::lazy_static;
 use regex::Regex;
 use zellij_utils::{
@@ -45,6 +46,7 @@ pub struct StdinAnsiParser {
     pending_color_sequences: Vec<(usize, String)>,
     pending_events: Vec<AnsiStdinInstruction>,
     parse_deadline: Option<Instant>,
+    pending_clipboard_responses: usize,
 }
 
 impl StdinAnsiParser {
@@ -54,6 +56,7 @@ impl StdinAnsiParser {
             pending_color_sequences: vec![],
             pending_events: vec![],
             parse_deadline: None,
+            pending_clipboard_responses: 0,
         }
     }
     pub fn terminal_emulator_query_string(&mut self) -> String {
@@ -78,6 +81,11 @@ impl StdinAnsiParser {
             Some(Instant::now() + Duration::from_millis(STARTUP_PARSE_DEADLINE_MS));
         query_string
     }
+    pub fn expect_clipboard_response(&mut self) {
+        self.pending_clipboard_responses += 1;
+        self.parse_deadline =
+            Some(Instant::now() + Duration::from_millis(CLIPBOARD_PARSE_DEADLINE_MS));
+    }
     fn drain_pending_events(&mut self) -> Vec<AnsiStdinInstruction> {
         let mut events = vec![];
         events.append(&mut self.pending_events);
@@ -88,10 +96,13 @@ impl StdinAnsiParser {
         }
         events
     }
-    pub fn should_parse(&self) -> bool {
+    pub fn should_parse(&mut self) -> bool {
         if let Some(parse_deadline) = self.parse_deadline {
             if parse_deadline >= Instant::now() {
                 return true;
+            } else {
+                self.parse_deadline = None;
+                self.pending_clipboard_responses = 0;
             }
         }
         false
@@ -135,7 +146,23 @@ impl StdinAnsiParser {
         };
     }
     fn parse_byte(&mut self, byte: u8) {
-        if byte == b't' {
+        if byte == 0x07 {
+            self.raw_buffer.push(byte);
+            if let Some(clipboard_sequence) =
+                AnsiStdinInstruction::clipboard_from_bytes(&self.raw_buffer)
+            {
+                if self.pending_clipboard_responses > 0 {
+                    self.pending_clipboard_responses -= 1;
+                }
+                if self.pending_clipboard_responses == 0 {
+                    self.parse_deadline = None;
+                }
+                self.pending_events.push(clipboard_sequence);
+                self.raw_buffer.clear();
+            } else {
+                self.raw_buffer.clear();
+            }
+        } else if byte == b't' {
             self.raw_buffer.push(byte);
             match AnsiStdinInstruction::pixel_dimensions_from_bytes(&self.raw_buffer) {
                 Ok(ansi_sequence) => {
@@ -157,6 +184,17 @@ impl StdinAnsiParser {
                 self.raw_buffer.clear();
                 self.pending_color_sequences
                     .push((color_register, color_sequence));
+            } else if let Some(clipboard_sequence) =
+                AnsiStdinInstruction::clipboard_from_bytes(&self.raw_buffer)
+            {
+                if self.pending_clipboard_responses > 0 {
+                    self.pending_clipboard_responses -= 1;
+                }
+                if self.pending_clipboard_responses == 0 {
+                    self.parse_deadline = None;
+                }
+                self.pending_events.push(clipboard_sequence);
+                self.raw_buffer.clear();
             } else {
                 self.raw_buffer.clear();
             }
@@ -181,6 +219,7 @@ pub enum AnsiStdinInstruction {
     ForegroundColor(String),
     ColorRegisters(Vec<(usize, String)>),
     SynchronizedOutput(Option<SyncOutput>),
+    ClipboardContent(Vec<u8>),
 }
 
 impl AnsiStdinInstruction {
@@ -224,6 +263,22 @@ impl AnsiStdinInstruction {
             _ => Err("invalid sequence"),
         }
     }
+    pub fn clipboard_from_bytes(bytes: &[u8]) -> Option<Self> {
+        if !bytes.starts_with(b"\x1b]52;") {
+            return None;
+        }
+        let content = if let Some(pos) = bytes.iter().position(|&b| b == 0x07) {
+            &bytes[..=pos]
+        } else if bytes.len() >= 2
+            && bytes[bytes.len() - 2] == b'\x1b'
+            && bytes[bytes.len() - 1] == b'\\'
+        {
+            bytes
+        } else {
+            return None;
+        };
+        Some(AnsiStdinInstruction::ClipboardContent(content.to_vec()))
+    }
     pub fn bg_or_fg_from_bytes(bytes: &[u8]) -> Result<Self, &'static str> {
         // eg. <ESC>]11;rgb:0000/0000/0000\
         lazy_static! {
@@ -284,6 +339,27 @@ impl AnsiStdinInstruction {
     }
 }
 
+#[cfg(test)]
+mod tests {
+    use super::{AnsiStdinInstruction, StdinAnsiParser};
+
+    #[test]
+    fn parses_osc52_clipboard_response() {
+        let mut parser = StdinAnsiParser::new();
+        parser.expect_clipboard_response();
+        let osc_sequence = b"\x1b]52;c;YmF6\x07".to_vec();
+        let events = parser.parse(osc_sequence);
+        assert_eq!(events.len(), 1);
+        match &events[0] {
+            AnsiStdinInstruction::ClipboardContent(bytes) => {
+                assert_eq!(bytes, b"\x1b]52;c;YmF6\x07");
+            },
+            other => panic!("Expected ClipboardContent, got {:?}", other),
+        }
+        assert!(!parser.should_parse());
+    }
+}
+
 fn color_sequence_from_bytes(bytes: &[u8]) -> Result<(usize, String), &'static str> {
     lazy_static! {
         static ref COLOR_REGISTER_RE: Regex = Regex::new(r"\]4;(.*);(.*)\u{1b}\\$").unwrap();
diff --git a/zellij-client/src/stdin_handler.rs b/zellij-client/src/stdin_handler.rs
index 7ec335f7..26f113e6 100644
--- a/zellij-client/src/stdin_handler.rs
+++ b/zellij-client/src/stdin_handler.rs
@@ -1,6 +1,6 @@
 use crate::keyboard_parser::KittyKeyboardParser;
 use crate::os_input_output::ClientOsApi;
-use crate::stdin_ansi_parser::StdinAnsiParser;
+use crate::stdin_ansi_parser::{AnsiStdinInstruction, StdinAnsiParser};
 use crate::InputInstruction;
 use std::sync::{Arc, Mutex};
 use termwiz::input::{InputEvent, InputParser, MouseButtons};
@@ -73,7 +73,19 @@ pub(crate) fn stdin_loop(
                     if stdin_ansi_parser.should_parse() {
                         let events = stdin_ansi_parser.parse(buf);
                         if !events.is_empty() {
-                            ansi_stdin_events.append(&mut events.clone());
+                            let mut cacheable_events: Vec<_> = events
+                                .iter()
+                                .filter(|event| {
+                                    !matches!(
+                                        event,
+                                        AnsiStdinInstruction::ClipboardContent(..)
+                                    )
+                                })
+                                .cloned()
+                                .collect();
+                            if !cacheable_events.is_empty() {
+                                ansi_stdin_events.append(&mut cacheable_events);
+                            }
                             let _ = send_input_instructions
                                 .send(InputInstruction::AnsiStdinInstructions(events));
                         }
diff --git a/zellij-client/src/web_client/server_listener.rs b/zellij-client/src/web_client/server_listener.rs
index 1bbf4d56..f138b868 100644
--- a/zellij-client/src/web_client/server_listener.rs
+++ b/zellij-client/src/web_client/server_listener.rs
@@ -131,6 +131,12 @@ pub fn zellij_server_listener(
                                 reconnect_to_session = Some(connect_to_session);
                                 continue 'reconnect_loop;
                             },
+                            Some(ServerToClientMsg::StartOsc52ClipboardQuery { selector }) => {
+                                log::debug!(
+                                    "Web client received OSC 52 clipboard query for selector {:?}, ignoring",
+                                    String::from_utf8_lossy(&selector)
+                                );
+                            },
                             Some(ServerToClientMsg::QueryTerminalSize) => {
                                 client_connection_bus.send_control(
                                     WebServerToWebClientControlMessage::QueryTerminalSize,
diff --git a/zellij-server/src/panes/grid.rs b/zellij-server/src/panes/grid.rs
index b26364df..bea41c2d 100644
--- a/zellij-server/src/panes/grid.rs
+++ b/zellij-server/src/panes/grid.rs
@@ -363,6 +363,7 @@ pub struct Grid {
     pub focus_event_tracking: bool,
     pub search_results: SearchResult,
     pub pending_clipboard_update: Option<String>,
+    pub pending_clipboard_query: Option<Vec<u8>>,
     ui_component_bytes: Option<Vec<u8>>,
     style: Style,
     debug: bool,
@@ -562,6 +563,7 @@ impl Grid {
             search_results: Default::default(),
             sixel_grid,
             pending_clipboard_update: None,
+            pending_clipboard_query: None,
             ui_component_bytes: None,
             style,
             debug,
@@ -2774,10 +2776,19 @@ impl Perform for Grid {
                     return;
                 }
 
-                let _clipboard = params[1].get(0).unwrap_or(&b'c');
+                let clipboard_param = params.get(1).and_then(|p| p.first()).copied();
                 match params[2] {
                     b"?" => {
-                        // TBD: paste from own clipboard - currently unsupported
+                        // Clipboard query - forward to terminal emulator
+                        // Store the full parameter to echo it back exactly
+                        let param_to_store = clipboard_param
+                            .map(|c| vec![c])
+                            .unwrap_or_else(|| b"c".to_vec());
+                        log::info!(
+                            "OSC 52 clipboard query detected! Parameter: {:?}",
+                            String::from_utf8_lossy(&param_to_store)
+                        );
+                        self.pending_clipboard_query = Some(param_to_store);
                     },
                     base64 => {
                         if let Ok(bytes) = base64::decode(base64) {
diff --git a/zellij-server/src/panes/terminal_pane.rs b/zellij-server/src/panes/terminal_pane.rs
index 3f251bbd..39a2bf01 100644
--- a/zellij-server/src/panes/terminal_pane.rs
+++ b/zellij-server/src/panes/terminal_pane.rs
@@ -563,6 +563,10 @@ impl Pane for TerminalPane {
         self.grid.pending_clipboard_update.take()
     }
 
+    fn drain_clipboard_query(&mut self) -> Option<Vec<u8>> {
+        self.grid.pending_clipboard_query.take()
+    }
+
     fn start_selection(&mut self, start: &Position, _client_id: ClientId) {
         self.grid.start_selection(start);
         self.set_should_render(true);
diff --git a/zellij-server/src/route.rs b/zellij-server/src/route.rs
index db721e1f..41b4f6a3 100644
--- a/zellij-server/src/route.rs
+++ b/zellij-server/src/route.rs
@@ -1266,6 +1266,19 @@ pub(crate) fn route_thread_main(
                             let _ =
                                 to_server.send(ServerInstruction::FailedToStartWebServer(error));
                         },
+                        ClientToServerMsg::Osc52ClipboardContent { ref clipboard_content } => {
+                            let clipboard_bytes = clipboard_content.clone();
+                            send_to_screen_or_retry_queue!(
+                                rlocked_sessions,
+                                ScreenInstruction::Osc52ClipboardResponse {
+                                    client_id,
+                                    clipboard_content: clipboard_bytes,
+                                },
+                                instruction,
+                                retry_queue
+                            )
+                            .with_context(err_context)?;
+                        },
                     }
                     Ok(should_break)
                 };
diff --git a/zellij-server/src/screen.rs b/zellij-server/src/screen.rs
index 0cd0b234..dae8fd11 100644
--- a/zellij-server/src/screen.rs
+++ b/zellij-server/src/screen.rs
@@ -256,6 +256,10 @@ pub enum ScreenInstruction {
     TerminalBackgroundColor(String),
     TerminalForegroundColor(String),
     TerminalColorRegisters(Vec<(usize, String)>),
+    Osc52ClipboardResponse {
+        client_id: ClientId,
+        clipboard_content: Vec<u8>,
+    },
     ChangeMode(ModeInfo, ClientId),
     ChangeModeForAllClients(ModeInfo),
     MouseEvent(MouseEvent, ClientId),
@@ -539,6 +543,9 @@ impl From<&ScreenInstruction> for ScreenContext {
                 ScreenContext::TerminalForegroundColor
             },
             ScreenInstruction::TerminalColorRegisters(..) => ScreenContext::TerminalColorRegisters,
+            ScreenInstruction::Osc52ClipboardResponse { .. } => {
+                ScreenContext::Osc52ClipboardResponse
+            },
             ScreenInstruction::ChangeMode(..) => ScreenContext::ChangeMode,
             ScreenInstruction::ChangeModeForAllClients(..) => {
                 ScreenContext::ChangeModeForAllClients
@@ -4425,6 +4432,29 @@ pub(crate) fn screen_thread_main(
             ScreenInstruction::TerminalColorRegisters(color_registers) => {
                 screen.update_terminal_color_registers(color_registers);
             },
+            ScreenInstruction::Osc52ClipboardResponse {
+                client_id,
+                clipboard_content,
+            } => {
+                if let Some((_, tab)) = screen
+                    .tabs
+                    .iter_mut()
+                    .find(|(_, tab)| tab.has_pending_clipboard_query_for(client_id))
+                {
+                    if let Err(err) = tab
+                        .handle_clipboard_response_from_client(client_id, clipboard_content)
+                    {
+                        Err::<(), _>(err)
+                            .context("failed to forward OSC 52 clipboard response")
+                            .non_fatal();
+                    }
+                } else {
+                    log::debug!(
+                        "OSC 52 clipboard response received for client {:?} with no pending query",
+                        client_id
+                    );
+                }
+            },
             ScreenInstruction::ChangeMode(mode_info, client_id) => {
                 screen.change_mode(mode_info, client_id)?;
                 screen.render(None)?;
diff --git a/zellij-server/src/tab/mod.rs b/zellij-server/src/tab/mod.rs
index 291fd6b7..c52ea198 100644
--- a/zellij-server/src/tab/mod.rs
+++ b/zellij-server/src/tab/mod.rs
@@ -50,13 +50,14 @@ use std::cell::RefCell;
 use std::rc::Rc;
 use std::time::Instant;
 use std::{
-    collections::{BTreeMap, HashMap, HashSet},
+    collections::{BTreeMap, HashMap, HashSet, VecDeque},
     str,
 };
 use zellij_utils::{
     data::{
         Event, FloatingPaneCoordinates, InputMode, ModeInfo, Palette, PaletteColor, Style, Styling,
     },
+    ipc::ServerToClientMsg,
     input::{
         command::TerminalAction,
         layout::{
@@ -218,6 +219,10 @@ impl MouseEffect {
     }
 }
 
+struct PendingClipboardQuery {
+    pane_id: u32,
+}
+
 pub(crate) struct Tab {
     pub index: usize,
     pub position: usize,
@@ -242,6 +247,7 @@ pub(crate) struct Tab {
     draw_pane_frames: bool,
     auto_layout: bool,
     pending_vte_events: HashMap<u32, Vec<VteBytes>>,
+    pending_clipboard_queries: HashMap<ClientId, VecDeque<PendingClipboardQuery>>,
     pub selecting_with_mouse_in_pane: Option<PaneId>, // this is only pub for the tests
     link_handler: Rc<RefCell<LinkHandler>>,
     clipboard_provider: ClipboardProvider,
@@ -465,6 +471,9 @@ pub trait Pane {
     fn drain_clipboard_update(&mut self) -> Option<String> {
         None
     }
+    fn drain_clipboard_query(&mut self) -> Option<Vec<u8>> {
+        None
+    }
     fn render_full_viewport(&mut self) {}
     fn relative_position(&self, position_on_screen: &Position) -> Position {
         position_on_screen.relative_to(self.get_content_y(), self.get_content_x())
@@ -779,6 +788,7 @@ impl Tab {
             draw_pane_frames,
             auto_layout,
             pending_vte_events: HashMap::new(),
+            pending_clipboard_queries: HashMap::new(),
             connected_clients,
             selecting_with_mouse_in_pane: None,
             link_handler: Rc::new(RefCell::new(LinkHandler::new())),
@@ -1125,6 +1135,7 @@ impl Tab {
     pub fn remove_client(&mut self, client_id: ClientId) {
         self.focus_pane_id = None;
         self.connected_clients.borrow_mut().remove(&client_id);
+        self.pending_clipboard_queries.remove(&client_id);
         self.set_force_render();
     }
     pub fn drain_connected_clients(
@@ -1147,6 +1158,7 @@ impl Tab {
             .remove(&client_id)
             .unwrap_or_else(|| self.default_mode_info.clone());
         self.connected_clients.borrow_mut().remove(&client_id);
+        self.pending_clipboard_queries.remove(&client_id);
         (client_id, client_mode_info)
     }
     pub fn has_no_connected_clients(&self) -> bool {
@@ -2337,6 +2349,7 @@ impl Tab {
             terminal_output.handle_pty_bytes(bytes);
             let messages_to_pty = terminal_output.drain_messages_to_pty();
             let clipboard_update = terminal_output.drain_clipboard_update();
+            let clipboard_query = terminal_output.drain_clipboard_query();
             for message in messages_to_pty {
                 self.write_to_pane_id_without_preprocessing(message, PaneId::Terminal(pid))
                     .with_context(err_context)?;
@@ -2345,6 +2358,14 @@ impl Tab {
                 self.write_selection_to_clipboard(&string)
                     .with_context(err_context)?;
             }
+            if let Some(clipboard_param) = clipboard_query {
+                log::info!(
+                    "Draining clipboard query from terminal pane, parameter: {:?}",
+                    String::from_utf8_lossy(&clipboard_param)
+                );
+                self.request_clipboard_content(pid, &clipboard_param)
+                    .with_context(err_context)?;
+            }
         }
         Ok(())
     }
@@ -4577,36 +4598,50 @@ impl Tab {
         Ok(())
     }
 
-    fn write_selection_to_clipboard(&self, selection: &str) -> Result<()> {
-        let err_context = || format!("failed to write selection to clipboard: '{}'", selection);
-
-        let mut output = Output::default();
+    /// Helper to send instructions to connected clients
+    fn send_to_connected_clients<F>(
+        &self,
+        add_instructions: F,
+    ) -> Result<HashSet<ClientId>>
+    where
+        F: FnOnce(&mut Output, &HashSet<ClientId>),
+    {
         let connected_clients: HashSet<ClientId> =
             { self.connected_clients.borrow().iter().copied().collect() };
+
+        // Bail early if no clients
+        if connected_clients.is_empty() {
+            return Ok(HashSet::new());
+        }
+
+        let mut output = Output::default();
         output.add_clients(&connected_clients, self.link_handler.clone(), None);
-        let client_ids = connected_clients.iter().copied();
-        let clipboard_event =
-            match self
+
+        add_instructions(&mut output, &connected_clients);
+
+        output.serialize().and_then(|serialized_output| {
+            self.senders
+                .send_to_server(ServerInstruction::Render(Some(serialized_output)))
+        })?;
+
+        Ok(connected_clients)
+    }
+
+    fn write_selection_to_clipboard(&self, selection: &str) -> Result<()> {
+        let err_context = || format!("failed to write selection to clipboard: '{}'", selection);
+
+        let clipboard_event = match self.send_to_connected_clients(|output, client_ids| {
+            let _ = self
                 .clipboard_provider
-                .set_content(selection, &mut output, client_ids)
-            {
-                Ok(_) => output
-                    .serialize()
-                    .and_then(|serialized_output| {
-                        self.senders
-                            .send_to_server(ServerInstruction::Render(Some(serialized_output)))
-                    })
-                    .and_then(|_| {
-                        Ok(Event::CopyToClipboard(
-                            self.clipboard_provider.as_copy_destination(),
-                        ))
-                    })
-                    .with_context(err_context)?,
-                Err(err) => {
-                    Err::<(), _>(err).with_context(err_context).non_fatal();
-                    Event::SystemClipboardFailure
-                },
-            };
+                .set_content(selection, output, client_ids.iter().copied());
+        }) {
+            Ok(_) => Event::CopyToClipboard(self.clipboard_provider.as_copy_destination()),
+            Err(err) => {
+                Err::<(), _>(err).with_context(err_context).non_fatal();
+                Event::SystemClipboardFailure
+            },
+        };
+
         self.senders
             .send_to_plugin(PluginInstruction::Update(vec![(
                 None,
@@ -4618,6 +4653,111 @@ impl Tab {
 
         Ok(())
     }
+
+    fn request_clipboard_content(
+        &mut self,
+        pane_pid: u32,
+        clipboard_param: &[u8],
+    ) -> Result<()> {
+        let err_context = || "failed to request clipboard content";
+
+        let selector_vec = if clipboard_param.is_empty() {
+            vec![b'c']
+        } else {
+            clipboard_param.to_vec()
+        };
+        let clipboard_selector = String::from_utf8_lossy(&selector_vec);
+        log::info!(
+            "Tab received clipboard query request with parameter: {:?}",
+            clipboard_selector
+        );
+
+        // Only support clipboard queries when using OSC52
+        match &self.clipboard_provider {
+            ClipboardProvider::Osc52(_) => {
+                log::info!(
+                    "Forwarding OSC 52 query to terminal emulator: ESC]52;{};?ESC\\",
+                    clipboard_selector
+                );
+                // Forward the OSC 52 query to the terminal emulator
+                let connected_clients = self
+                    .send_to_connected_clients(|output, client_ids| {
+                        output.add_pre_vte_instruction_to_multiple_clients(
+                            client_ids.iter().copied(),
+                            &format!("\u{1b}]52;{};?\u{1b}\\", clipboard_selector),
+                        );
+                    })
+                    .with_context(err_context)?;
+                if connected_clients.is_empty() {
+                    log::debug!("No connected clients to satisfy OSC 52 clipboard query");
+                    return Ok(());
+                }
+                for client_id in connected_clients {
+                    match self.os_api.send_to_client(
+                        client_id,
+                        ServerToClientMsg::StartOsc52ClipboardQuery {
+                            selector: selector_vec.clone(),
+                        },
+                    ) {
+                        Ok(()) => {
+                            self.pending_clipboard_queries
+                                .entry(client_id)
+                                .or_default()
+                                .push_back(PendingClipboardQuery { pane_id: pane_pid });
+                        },
+                        Err(err) => {
+                            Err::<(), _>(err).with_context(err_context).non_fatal();
+                        },
+                    }
+                }
+                log::info!("OSC 52 query forwarded successfully to clients");
+            },
+            ClipboardProvider::Command(_) => {
+                // Can't satisfy clipboard queries with external command backend
+                log::info!(
+                    "Ignoring OSC 52 clipboard query - external copy command configured, \
+                     OSC 52 passthrough not available"
+                );
+            },
+        }
+
+        Ok(())
+    }
+
+    pub(crate) fn has_pending_clipboard_query_for(&self, client_id: ClientId) -> bool {
+        self.pending_clipboard_queries
+            .get(&client_id)
+            .map(|queries| !queries.is_empty())
+            .unwrap_or(false)
+    }
+
+    pub(crate) fn handle_clipboard_response_from_client(
+        &mut self,
+        client_id: ClientId,
+        clipboard_bytes: Vec<u8>,
+    ) -> Result<bool> {
+        if let Some(queue) = self.pending_clipboard_queries.get_mut(&client_id) {
+            if let Some(pending_query) = queue.pop_front() {
+                if queue.is_empty() {
+                    self.pending_clipboard_queries.remove(&client_id);
+                }
+                log::debug!(
+                    "Forwarding OSC 52 response from client {:?} to pane {}",
+                    client_id, pending_query.pane_id
+                );
+                self.write_to_pane_id_without_preprocessing(
+                    clipboard_bytes,
+                    PaneId::Terminal(pending_query.pane_id),
+                )?;
+                return Ok(true);
+            }
+        }
+        log::debug!(
+            "Received OSC 52 clipboard response for client {:?} with no pending query",
+            client_id
+        );
+        Ok(false)
+    }
     pub fn visible(&mut self, visible: bool) -> Result<()> {
         let pids_in_this_tab = self.tiled_panes.pane_ids().filter_map(|p| match p {
             PaneId::Plugin(pid) => Some(pid),
diff --git a/zellij-utils/assets/prost_ipc/client_server_contract.rs b/zellij-utils/assets/prost_ipc/client_server_contract.rs
index 0f245cc9..dab8cf63 100644
--- a/zellij-utils/assets/prost_ipc/client_server_contract.rs
+++ b/zellij-utils/assets/prost_ipc/client_server_contract.rs
@@ -2168,124 +2168,8 @@ impl WebSharing {
 }
 #[allow(clippy::derive_partial_eq_without_eq)]
 #[derive(Clone, PartialEq, ::prost::Message)]
-pub struct ServerToClientMsg {
-    #[prost(oneof="server_to_client_msg::Message", tags="1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13")]
-    pub message: ::core::option::Option<server_to_client_msg::Message>,
-}
-/// Nested message and enum types in `ServerToClientMsg`.
-pub mod server_to_client_msg {
-    #[allow(clippy::derive_partial_eq_without_eq)]
-#[derive(Clone, PartialEq, ::prost::Oneof)]
-    pub enum Message {
-        #[prost(message, tag="1")]
-        Render(super::RenderMsg),
-        #[prost(message, tag="2")]
-        UnblockInputThread(super::UnblockInputThreadMsg),
-        #[prost(message, tag="3")]
-        Exit(super::ExitMsg),
-        #[prost(message, tag="4")]
-        Connected(super::ConnectedMsg),
-        #[prost(message, tag="5")]
-        Log(super::LogMsg),
-        #[prost(message, tag="6")]
-        LogError(super::LogErrorMsg),
-        #[prost(message, tag="7")]
-        SwitchSession(super::SwitchSessionMsg),
-        #[prost(message, tag="8")]
-        UnblockCliPipeInput(super::UnblockCliPipeInputMsg),
-        #[prost(message, tag="9")]
-        CliPipeOutput(super::CliPipeOutputMsg),
-        #[prost(message, tag="10")]
-        QueryTerminalSize(super::QueryTerminalSizeMsg),
-        #[prost(message, tag="11")]
-        StartWebServer(super::StartWebServerMsg),
-        #[prost(message, tag="12")]
-        RenamedSession(super::RenamedSessionMsg),
-        #[prost(message, tag="13")]
-        ConfigFileUpdated(super::ConfigFileUpdatedMsg),
-    }
-}
-#[allow(clippy::derive_partial_eq_without_eq)]
-#[derive(Clone, PartialEq, ::prost::Message)]
-pub struct RenderMsg {
-    #[prost(string, tag="1")]
-    pub content: ::prost::alloc::string::String,
-}
-/// Empty message
-#[allow(clippy::derive_partial_eq_without_eq)]
-#[derive(Clone, PartialEq, ::prost::Message)]
-pub struct UnblockInputThreadMsg {
-}
-#[allow(clippy::derive_partial_eq_without_eq)]
-#[derive(Clone, PartialEq, ::prost::Message)]
-pub struct ExitMsg {
-    #[prost(enumeration="ExitReason", tag="1")]
-    pub exit_reason: i32,
-    #[prost(string, optional, tag="2")]
-    pub payload: ::core::option::Option<::prost::alloc::string::String>,
-}
-/// Empty message
-#[allow(clippy::derive_partial_eq_without_eq)]
-#[derive(Clone, PartialEq, ::prost::Message)]
-pub struct ConnectedMsg {
-}
-#[allow(clippy::derive_partial_eq_without_eq)]
-#[derive(Clone, PartialEq, ::prost::Message)]
-pub struct LogMsg {
-    #[prost(string, repeated, tag="1")]
-    pub lines: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
-}
-#[allow(clippy::derive_partial_eq_without_eq)]
-#[derive(Clone, PartialEq, ::prost::Message)]
-pub struct LogErrorMsg {
-    #[prost(string, repeated, tag="1")]
-    pub lines: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
-}
-#[allow(clippy::derive_partial_eq_without_eq)]
-#[derive(Clone, PartialEq, ::prost::Message)]
-pub struct SwitchSessionMsg {
-    #[prost(message, optional, tag="1")]
-    pub connect_to_session: ::core::option::Option<ConnectToSession>,
-}
-#[allow(clippy::derive_partial_eq_without_eq)]
-#[derive(Clone, PartialEq, ::prost::Message)]
-pub struct UnblockCliPipeInputMsg {
-    #[prost(string, tag="1")]
-    pub pipe_name: ::prost::alloc::string::String,
-}
-#[allow(clippy::derive_partial_eq_without_eq)]
-#[derive(Clone, PartialEq, ::prost::Message)]
-pub struct CliPipeOutputMsg {
-    #[prost(string, tag="1")]
-    pub pipe_name: ::prost::alloc::string::String,
-    #[prost(string, tag="2")]
-    pub output: ::prost::alloc::string::String,
-}
-/// Empty message
-#[allow(clippy::derive_partial_eq_without_eq)]
-#[derive(Clone, PartialEq, ::prost::Message)]
-pub struct QueryTerminalSizeMsg {
-}
-/// Empty message
-#[allow(clippy::derive_partial_eq_without_eq)]
-#[derive(Clone, PartialEq, ::prost::Message)]
-pub struct StartWebServerMsg {
-}
-#[allow(clippy::derive_partial_eq_without_eq)]
-#[derive(Clone, PartialEq, ::prost::Message)]
-pub struct RenamedSessionMsg {
-    #[prost(string, tag="1")]
-    pub name: ::prost::alloc::string::String,
-}
-/// Empty message
-#[allow(clippy::derive_partial_eq_without_eq)]
-#[derive(Clone, PartialEq, ::prost::Message)]
-pub struct ConfigFileUpdatedMsg {
-}
-#[allow(clippy::derive_partial_eq_without_eq)]
-#[derive(Clone, PartialEq, ::prost::Message)]
 pub struct ClientToServerMsg {
-    #[prost(oneof="client_to_server_msg::Message", tags="1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15")]
+    #[prost(oneof="client_to_server_msg::Message", tags="1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16")]
     pub message: ::core::option::Option<client_to_server_msg::Message>,
 }
 /// Nested message and enum types in `ClientToServerMsg`.
@@ -2323,6 +2207,8 @@ pub mod client_to_server_msg {
         WebServerStarted(super::WebServerStartedMsg),
         #[prost(message, tag="15")]
         FailedToStartWebServer(super::FailedToStartWebServerMsg),
+        #[prost(message, tag="16")]
+        Osc52ClipboardContent(super::Osc52ClipboardContentMsg),
     }
 }
 #[allow(clippy::derive_partial_eq_without_eq)]
@@ -2428,3 +2314,133 @@ pub struct FailedToStartWebServerMsg {
     #[prost(string, tag="1")]
     pub error: ::prost::alloc::string::String,
 }
+#[allow(clippy::derive_partial_eq_without_eq)]
+#[derive(Clone, PartialEq, ::prost::Message)]
+pub struct Osc52ClipboardContentMsg {
+    #[prost(bytes="vec", tag="1")]
+    pub clipboard_content: ::prost::alloc::vec::Vec<u8>,
+}
+#[allow(clippy::derive_partial_eq_without_eq)]
+#[derive(Clone, PartialEq, ::prost::Message)]
+pub struct ServerToClientMsg {
+    #[prost(oneof="server_to_client_msg::Message", tags="1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14")]
+    pub message: ::core::option::Option<server_to_client_msg::Message>,
+}
+/// Nested message and enum types in `ServerToClientMsg`.
+pub mod server_to_client_msg {
+    #[allow(clippy::derive_partial_eq_without_eq)]
+#[derive(Clone, PartialEq, ::prost::Oneof)]
+    pub enum Message {
+        #[prost(message, tag="1")]
+        Render(super::RenderMsg),
+        #[prost(message, tag="2")]
+        UnblockInputThread(super::UnblockInputThreadMsg),
+        #[prost(message, tag="3")]
+        Exit(super::ExitMsg),
+        #[prost(message, tag="4")]
+        Connected(super::ConnectedMsg),
+        #[prost(message, tag="5")]
+        Log(super::LogMsg),
+        #[prost(message, tag="6")]
+        LogError(super::LogErrorMsg),
+        #[prost(message, tag="7")]
+        SwitchSession(super::SwitchSessionMsg),
+        #[prost(message, tag="8")]
+        UnblockCliPipeInput(super::UnblockCliPipeInputMsg),
+        #[prost(message, tag="9")]
+        CliPipeOutput(super::CliPipeOutputMsg),
+        #[prost(message, tag="10")]
+        QueryTerminalSize(super::QueryTerminalSizeMsg),
+        #[prost(message, tag="11")]
+        StartWebServer(super::StartWebServerMsg),
+        #[prost(message, tag="12")]
+        RenamedSession(super::RenamedSessionMsg),
+        #[prost(message, tag="13")]
+        ConfigFileUpdated(super::ConfigFileUpdatedMsg),
+        #[prost(message, tag="14")]
+        StartOsc52ClipboardQuery(super::StartOsc52ClipboardQueryMsg),
+    }
+}
+#[allow(clippy::derive_partial_eq_without_eq)]
+#[derive(Clone, PartialEq, ::prost::Message)]
+pub struct RenderMsg {
+    #[prost(string, tag="1")]
+    pub content: ::prost::alloc::string::String,
+}
+/// Empty message
+#[allow(clippy::derive_partial_eq_without_eq)]
+#[derive(Clone, PartialEq, ::prost::Message)]
+pub struct UnblockInputThreadMsg {
+}
+#[allow(clippy::derive_partial_eq_without_eq)]
+#[derive(Clone, PartialEq, ::prost::Message)]
+pub struct ExitMsg {
+    #[prost(enumeration="ExitReason", tag="1")]
+    pub exit_reason: i32,
+    #[prost(string, optional, tag="2")]
+    pub payload: ::core::option::Option<::prost::alloc::string::String>,
+}
+/// Empty message
+#[allow(clippy::derive_partial_eq_without_eq)]
+#[derive(Clone, PartialEq, ::prost::Message)]
+pub struct ConnectedMsg {
+}
+#[allow(clippy::derive_partial_eq_without_eq)]
+#[derive(Clone, PartialEq, ::prost::Message)]
+pub struct LogMsg {
+    #[prost(string, repeated, tag="1")]
+    pub lines: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
+}
+#[allow(clippy::derive_partial_eq_without_eq)]
+#[derive(Clone, PartialEq, ::prost::Message)]
+pub struct LogErrorMsg {
+    #[prost(string, repeated, tag="1")]
+    pub lines: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
+}
+#[allow(clippy::derive_partial_eq_without_eq)]
+#[derive(Clone, PartialEq, ::prost::Message)]
+pub struct SwitchSessionMsg {
+    #[prost(message, optional, tag="1")]
+    pub connect_to_session: ::core::option::Option<ConnectToSession>,
+}
+#[allow(clippy::derive_partial_eq_without_eq)]
+#[derive(Clone, PartialEq, ::prost::Message)]
+pub struct UnblockCliPipeInputMsg {
+    #[prost(string, tag="1")]
+    pub pipe_name: ::prost::alloc::string::String,
+}
+#[allow(clippy::derive_partial_eq_without_eq)]
+#[derive(Clone, PartialEq, ::prost::Message)]
+pub struct CliPipeOutputMsg {
+    #[prost(string, tag="1")]
+    pub pipe_name: ::prost::alloc::string::String,
+    #[prost(string, tag="2")]
+    pub output: ::prost::alloc::string::String,
+}
+/// Empty message
+#[allow(clippy::derive_partial_eq_without_eq)]
+#[derive(Clone, PartialEq, ::prost::Message)]
+pub struct QueryTerminalSizeMsg {
+}
+/// Empty message
+#[allow(clippy::derive_partial_eq_without_eq)]
+#[derive(Clone, PartialEq, ::prost::Message)]
+pub struct StartWebServerMsg {
+}
+#[allow(clippy::derive_partial_eq_without_eq)]
+#[derive(Clone, PartialEq, ::prost::Message)]
+pub struct RenamedSessionMsg {
+    #[prost(string, tag="1")]
+    pub name: ::prost::alloc::string::String,
+}
+/// Empty message
+#[allow(clippy::derive_partial_eq_without_eq)]
+#[derive(Clone, PartialEq, ::prost::Message)]
+pub struct ConfigFileUpdatedMsg {
+}
+#[allow(clippy::derive_partial_eq_without_eq)]
+#[derive(Clone, PartialEq, ::prost::Message)]
+pub struct StartOsc52ClipboardQueryMsg {
+    #[prost(bytes="vec", tag="1")]
+    pub selector: ::prost::alloc::vec::Vec<u8>,
+}
diff --git a/zellij-utils/src/client_server_contract/client_to_server.proto b/zellij-utils/src/client_server_contract/client_to_server.proto
index f9b01994..45b5baaf 100644
--- a/zellij-utils/src/client_server_contract/client_to_server.proto
+++ b/zellij-utils/src/client_server_contract/client_to_server.proto
@@ -20,6 +20,7 @@ message ClientToServerMsg {
     ConnStatusMsg conn_status = 13;
     WebServerStartedMsg web_server_started = 14;
     FailedToStartWebServerMsg failed_to_start_web_server = 15;
+    Osc52ClipboardContentMsg osc52_clipboard_content = 16;
   }
 }
 
@@ -90,3 +91,7 @@ message WebServerStartedMsg {
 message FailedToStartWebServerMsg {
   string error = 1;
 }
+
+message Osc52ClipboardContentMsg {
+  bytes clipboard_content = 1;
+}
diff --git a/zellij-utils/src/client_server_contract/server_to_client.proto b/zellij-utils/src/client_server_contract/server_to_client.proto
index 57813ebb..73dc454c 100644
--- a/zellij-utils/src/client_server_contract/server_to_client.proto
+++ b/zellij-utils/src/client_server_contract/server_to_client.proto
@@ -18,6 +18,7 @@ message ServerToClientMsg {
     StartWebServerMsg start_web_server = 11;
     RenamedSessionMsg renamed_session = 12;
     ConfigFileUpdatedMsg config_file_updated = 13;
+    StartOsc52ClipboardQueryMsg start_osc52_clipboard_query = 14;
   }
 }
 
@@ -74,3 +75,7 @@ message RenamedSessionMsg {
 message ConfigFileUpdatedMsg {
   // Empty message
 }
+
+message StartOsc52ClipboardQueryMsg {
+  bytes selector = 1;
+}
diff --git a/zellij-utils/src/errors.rs b/zellij-utils/src/errors.rs
index 624ef414..53372a0d 100644
--- a/zellij-utils/src/errors.rs
+++ b/zellij-utils/src/errors.rs
@@ -300,6 +300,7 @@ pub enum ScreenContext {
     TerminalBackgroundColor,
     TerminalForegroundColor,
     TerminalColorRegisters,
+    Osc52ClipboardResponse,
     ChangeMode,
     ChangeModeForAllClients,
     LeftClick,
diff --git a/zellij-utils/src/ipc.rs b/zellij-utils/src/ipc.rs
index fdffaa07..4e6170e6 100644
--- a/zellij-utils/src/ipc.rs
+++ b/zellij-utils/src/ipc.rs
@@ -133,6 +133,9 @@ pub enum ClientToServerMsg {
     FailedToStartWebServer {
         error: String,
     },
+    Osc52ClipboardContent {
+        clipboard_content: Vec<u8>,
+    },
 }
 
 // Types of messages sent from the server to the client
@@ -168,6 +171,9 @@ pub enum ServerToClientMsg {
         name: String,
     },
     ConfigFileUpdated,
+    StartOsc52ClipboardQuery {
+        selector: Vec<u8>,
+    },
 }
 
 #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
diff --git a/zellij-utils/src/ipc/protobuf_conversion.rs b/zellij-utils/src/ipc/protobuf_conversion.rs
index 7471f49c..adbbbfdc 100644
--- a/zellij-utils/src/ipc/protobuf_conversion.rs
+++ b/zellij-utils/src/ipc/protobuf_conversion.rs
@@ -5,9 +5,9 @@ use crate::{
         ColorRegistersMsg, ConfigFileUpdatedMsg, ConnStatusMsg, ConnectedMsg, DetachSessionMsg,
         ExitMsg, ExitReason as ProtoExitReason, FailedToStartWebServerMsg, FirstClientConnectedMsg,
         ForegroundColorMsg, InputMode as ProtoInputMode, KeyMsg, KillSessionMsg, LogErrorMsg,
-        LogMsg, QueryTerminalSizeMsg, RenamedSessionMsg, RenderMsg,
-        ServerToClientMsg as ProtoServerToClientMsg, StartWebServerMsg, SwitchSessionMsg,
-        TerminalPixelDimensionsMsg, TerminalResizeMsg, UnblockCliPipeInputMsg,
+        LogMsg, Osc52ClipboardContentMsg, QueryTerminalSizeMsg, RenamedSessionMsg, RenderMsg,
+        ServerToClientMsg as ProtoServerToClientMsg, StartOsc52ClipboardQueryMsg, StartWebServerMsg,
+        SwitchSessionMsg, TerminalPixelDimensionsMsg, TerminalResizeMsg, UnblockCliPipeInputMsg,
         UnblockInputThreadMsg, WebServerStartedMsg,
     },
     data::InputMode,
@@ -103,6 +103,11 @@ impl From<ClientToServerMsg> for ProtoClientToServerMsg {
                     error,
                 })
             },
+            ClientToServerMsg::Osc52ClipboardContent { clipboard_content } => {
+                client_to_server_msg::Message::Osc52ClipboardContent(
+                    Osc52ClipboardContentMsg { clipboard_content },
+                )
+            },
         };
 
         ProtoClientToServerMsg {
@@ -207,6 +212,11 @@ impl TryFrom<ProtoClientToServerMsg> for ClientToServerMsg {
                     error: failed.error,
                 })
             },
+            Some(client_to_server_msg::Message::Osc52ClipboardContent(osc52)) => {
+                Ok(ClientToServerMsg::Osc52ClipboardContent {
+                    clipboard_content: osc52.clipboard_content,
+                })
+            },
             None => Err(anyhow!("Empty ClientToServerMsg message")),
         }
     }
@@ -266,6 +276,11 @@ impl From<ServerToClientMsg> for ProtoServerToClientMsg {
             ServerToClientMsg::ConfigFileUpdated => {
                 server_to_client_msg::Message::ConfigFileUpdated(ConfigFileUpdatedMsg {})
             },
+            ServerToClientMsg::StartOsc52ClipboardQuery { selector } => {
+                server_to_client_msg::Message::StartOsc52ClipboardQuery(
+                    StartOsc52ClipboardQueryMsg { selector },
+                )
+            },
         };
 
         ProtoServerToClientMsg {
@@ -341,6 +356,11 @@ impl TryFrom<ProtoServerToClientMsg> for ServerToClientMsg {
             Some(server_to_client_msg::Message::ConfigFileUpdated(_)) => {
                 Ok(ServerToClientMsg::ConfigFileUpdated)
             },
+            Some(server_to_client_msg::Message::StartOsc52ClipboardQuery(query)) => {
+                Ok(ServerToClientMsg::StartOsc52ClipboardQuery {
+                    selector: query.selector,
+                })
+            },
             None => Err(anyhow!("Empty ServerToClientMsg message")),
         }
     }
-- 
2.44.2

